<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Claude Tower Defense</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      font-family: Arial, sans-serif;
      color: white;
      overflow-x: hidden;
    }

    .game-container {
      max-width: 1000px;
      margin: 0 auto;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(10px);
    }

    .start-screen {
      text-align: center;
      padding: 50px 20px;
      min-height: 500px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .game-logo {
      font-size: 48px;
      font-weight: bold;
      background: linear-gradient(45deg, #FFD700, #FFA500, #FF6347);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      margin-bottom: 20px;
      animation: glow 2s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from {
        filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
      }

      to {
        filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8));
      }
    }

    .game-subtitle {
      font-size: 18px;
      opacity: 0.8;
      margin-bottom: 40px;
      color: #E6E6FA;
    }

    .tower-emoji {
      font-size: 80px;
      margin: 20px 0;
      animation: bounce 2s infinite;
    }

    @keyframes bounce {

      0%,
      20%,
      50%,
      80%,
      100% {
        transform: translateY(0);
      }

      40% {
        transform: translateY(-10px);
      }

      60% {
        transform: translateY(-5px);
      }
    }

    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 10px;
    }

    .stats {
      display: flex;
      gap: 30px;
      font-size: 18px;
      font-weight: bold;
    }

    .stat-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .controls {
      display: flex;
      gap: 15px;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 18px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btn-start {
      background: linear-gradient(45deg, #FF6B6B, #FF8E8E);
      color: white;
      font-size: 20px;
      padding: 15px 40px;
      box-shadow: 0 8px 25px rgba(255, 107, 107, 0.3);
    }

    .btn-primary {
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
    }

    .btn-secondary {
      background: linear-gradient(45deg, #2196F3, #1976D2);
      color: white;
    }

    .btn-danger {
      background: linear-gradient(45deg, #f44336, #d32f2f);
      color: white;
    }

    .btn:hover,
    .controls a:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
    }

    .btn:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    #gameCanvas {
      border: 3px solid #fff;
      border-radius: 10px;
      background: #2d5a27;
      display: block;
      margin: 0 auto;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .game-info {
      margin-top: 15px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 10px;
      text-align: center;
    }

    .wave-info {
      font-size: 18px;
      margin-bottom: 10px;
    }

    .instructions {
      font-size: 14px;
      opacity: 0.8;
      line-height: 1.4;
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal {
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.1);
      max-width: 400px;
      width: 90%;
    }

    .modal h2 {
      font-size: 36px;
      color: #FF6B6B;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .modal p {
      font-size: 18px;
      margin-bottom: 30px;
      opacity: 0.9;
    }

    .hidden {
      display: none;
    }

    .game-screen {
      display: none;
    }

    .game-screen.active {
      display: block;
    }

    .controls a {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 16px;
      color: #000;
      text-decoration: none;
      background-color: #ddd;
      padding: 12px 24px;
      border-radius: 18px;
      transition: all 0.3s ease;
    }

    .controls img {
      width: 24px;
      height: 24px;
    }
  </style>
</head>

<body>
  <div class="game-container">
    <!-- Initial Screen -->
    <div id="startScreen" class="start-screen">
      <div class="game-logo">üè∞ Claude Tower Defense üè∞</div>
      <div class="tower-emoji">üóº</div>
      <div class="game-subtitle">Defend your base against waves of enemies!</div>

      <div class="controls">
        <button id="startGameBtn" class="btn btn-start">üéÆ Start Game</button>

        <a href="https://github.com/ItaloFalzoni/claude-tower-defense" target="_blank">
          <img src="./assets/icons/github.svg" alt="Github Icon">
          <span>√çtalo Falzoni</span>
        </a>
      </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="game-screen">
      <div class="game-header">
        <div class="stats">
          <div class="stat-item">
            <span>üí∞</span>
            <span id="coins">100</span>
          </div>
          <div class="stat-item">
            <span>‚ù§Ô∏è</span>
            <span id="health">20</span>
          </div>
          <div class="stat-item">
            <span>üåä</span>
            <span id="wave">1</span>
          </div>
          <div class="stat-item">
            <span>üëæ</span>
            <span id="enemiesLeft">5</span>
          </div>
        </div>
        <div class="controls">
          <button id="buyTower" class="btn btn-primary">Buy (üí∞50)</button>
          <button id="startWave" class="btn btn-secondary">Start Wave</button>
          <button id="resetGame" class="btn btn-danger">Restart Game</button>
        </div>
      </div>

      <canvas id="gameCanvas" width="800" height="500"></canvas>

      <div class="game-info">
        <div class="wave-info">
          <span id="waveStatus">Press "Start Wave"!</span>
        </div>
        <div class="instructions">
          üí° Instructions: Click on the field to place towers after purchasing them (üí∞50). Click on towers to select,
          upgrade, or sell. Green = valid position, Red = invalid. You earn üí∞15 per enemy defeated.
        </div>
      </div>
    </div>

    <!-- Modal Game Over -->
    <div id="gameOverModal" class="modal-overlay hidden">
      <div class="modal">
        <h2>üíÄ Game Over! üíÄ</h2>
        <p id="gameOverStats">You survived until Wave X!</p>
        <div style="margin: 20px 0;">
          <p id="finalStats"></p>
        </div>

        <div class="controls">
          <button id="restartBtn" class="btn btn-start">üîÑ Play Again</button>

          <a href="https://github.com/ItaloFalzoni/claude-tower-defense" target="_blank">
            <img src="./assets/icons/github.svg" alt="Github Icon">
            <span>√çtalo Falzoni</span>
          </a>
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Estado do jogo
    let gameState = {
      coins: 100,
      health: 20,
      wave: 1,
      enemiesLeft: 0,
      towers: [],
      enemies: [],
      bullets: [],
      waveActive: false,
      placingTower: false,
      enemiesSpawned: 0,
      enemiesPerWave: 5,
      mouseX: 0,
      mouseY: 0,
      selectedTower: null,
      enemiesKilled: 0,
      totalEnemiesKilled: 0,
      livesLostThisWave: 0,
      totalLivesLost: 0,
      coinsEarnedThisWave: 0,
      totalCoinsEarned: 0,
      gameStarted: false,
      gameOver: false
    };

    // Configura√ß√µes
    const config = {
      towerCost: 50,
      upgradeCost: 75,
      sellValue: 30,
      coinReward: 15,
      towerDamage: 25,
      towerRange: 80,
      bulletSpeed: 5,
      spawnDelay: 1000
    };

    // Caminho dos inimigos
    const path = [
      { x: 0, y: 250 },
      { x: 200, y: 250 },
      { x: 200, y: 150 },
      { x: 400, y: 150 },
      { x: 400, y: 350 },
      { x: 600, y: 350 },
      { x: 600, y: 250 },
      { x: 800, y: 250 }
    ];

    class Enemy {
      constructor() {
        this.x = path[0].x;
        this.y = path[0].y;
        this.pathIndex = 0;
        this.health = 50 + (gameState.wave - 1) * 25;
        this.maxHealth = this.health;
        this.speed = 1 + (gameState.wave - 1) * 0.3;
        this.radius = 15;
        this.color = '#ff4444';
      }

      update() {
        if (this.pathIndex < path.length - 1) {
          const target = path[this.pathIndex + 1];
          const dx = target.x - this.x;
          const dy = target.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 5) {
            this.pathIndex++;
          } else {
            this.x += (dx / distance) * this.speed;
            this.y += (dy / distance) * this.speed;
          }
        } else {
          gameState.health--;
          gameState.livesLostThisWave++;
          gameState.totalLivesLost++;
          this.remove();
        }
      }

      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        const barWidth = 30;
        const barHeight = 4;
        const healthPercent = this.health / this.maxHealth;

        ctx.fillStyle = '#ff0000';
        ctx.fillRect(this.x - barWidth / 2, this.y - this.radius - 10, barWidth, barHeight);

        ctx.fillStyle = '#00ff00';
        ctx.fillRect(this.x - barWidth / 2, this.y - this.radius - 10, barWidth * healthPercent, barHeight);
      }

      takeDamage(damage) {
        this.health -= damage;
        if (this.health <= 0) {
          gameState.coins += config.coinReward;
          gameState.enemiesKilled++;
          gameState.totalEnemiesKilled++;
          gameState.coinsEarnedThisWave += config.coinReward;
          gameState.totalCoinsEarned += config.coinReward;
          this.remove();
        }
      }

      remove() {
        const index = gameState.enemies.indexOf(this);
        if (index > -1) {
          gameState.enemies.splice(index, 1);
          gameState.enemiesLeft--;
        }
      }
    }

    class Tower {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.level = 1;
        this.range = config.towerRange;
        this.damage = config.towerDamage;
        this.cooldown = 0;
        this.maxCooldown = 30;
        this.target = null;
        this.selected = false;
      }

      upgrade() {
        if (this.level < 3) {
          this.level++;
          this.range += 20;
          this.damage += 15;
          this.maxCooldown = Math.max(10, this.maxCooldown - 5);
        }
      }

      getUpgradeCost() {
        return config.upgradeCost * this.level;
      }

      getSellValue() {
        return config.sellValue + (this.level - 1) * 25;
      }

      update() {
        if (this.cooldown > 0) this.cooldown--;

        this.target = null;
        let closestDistance = this.range;

        for (let enemy of gameState.enemies) {
          const dx = enemy.x - this.x;
          const dy = enemy.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < closestDistance) {
            this.target = enemy;
            closestDistance = distance;
          }
        }

        if (this.target && this.cooldown === 0) {
          this.shoot();
          this.cooldown = this.maxCooldown;
        }
      }

      shoot() {
        const bullet = new Bullet(this.x, this.y, this.target, this.damage);
        gameState.bullets.push(bullet);
      }

      draw() {
        const baseColors = ['#8B4513', '#CD853F', '#DAA520'];
        const towerColors = ['#A0522D', '#D2B48C', '#FFD700'];

        ctx.fillStyle = baseColors[this.level - 1];
        const baseSize = 15 + this.level * 2;
        ctx.fillRect(this.x - baseSize, this.y - baseSize, baseSize * 2, baseSize * 2);

        ctx.fillStyle = towerColors[this.level - 1];
        const towerSize = 10 + this.level * 2;
        ctx.fillRect(this.x - towerSize, this.y - 20 - this.level, towerSize * 2, 10 + this.level);

        if (this.target) {
          const dx = this.target.x - this.x;
          const dy = this.target.y - this.y;
          const angle = Math.atan2(dy, dx);

          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(angle);

          ctx.fillStyle = '#2F4F4F';
          ctx.fillRect(0, -3, 25 + this.level * 3, 6);

          ctx.restore();
        }

        if (this.selected) {
          ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
          ctx.stroke();

          this.drawActionButtons();
        }

        if (this.level > 1) {
          ctx.fillStyle = '#FFD700';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('‚òÖ'.repeat(this.level - 1), this.x, this.y - baseSize - 5);
        }
      }

      drawActionButtons() {
        if (this.level < 3) {
          ctx.fillStyle = gameState.coins >= this.getUpgradeCost() ? '#4CAF50' : '#666';
          ctx.fillRect(this.x - 30, this.y + 30, 25, 15);
          ctx.fillStyle = 'white';
          ctx.font = '10px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('UP', this.x - 17.5, this.y + 41);
        }

        ctx.fillStyle = '#f44336';
        ctx.fillRect(this.x + 5, this.y + 30, 25, 15);
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('SELL', this.x + 17.5, this.y + 41);
      }

      isPointInside(x, y) {
        const size = 15 + this.level * 2;
        return x >= this.x - size && x <= this.x + size &&
          y >= this.y - size && y <= this.y + size;
      }

      isPointInUpgradeButton(x, y) {
        return this.level < 3 && x >= this.x - 30 && x <= this.x - 5 &&
          y >= this.y + 30 && y <= this.y + 45;
      }

      isPointInSellButton(x, y) {
        return x >= this.x + 5 && x <= this.x + 30 &&
          y >= this.y + 30 && y <= this.y + 45;
      }
    }

    class Bullet {
      constructor(x, y, target, damage) {
        this.x = x;
        this.y = y;
        this.target = target;
        this.damage = damage;
        this.speed = config.bulletSpeed;
        this.radius = 3;
      }

      update() {
        if (!this.target || gameState.enemies.indexOf(this.target) === -1) {
          this.remove();
          return;
        }

        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < 10) {
          this.target.takeDamage(this.damage);
          this.remove();
        } else {
          this.x += (dx / distance) * this.speed;
          this.y += (dy / distance) * this.speed;
        }
      }

      draw() {
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }

      remove() {
        const index = gameState.bullets.indexOf(this);
        if (index > -1) {
          gameState.bullets.splice(index, 1);
        }
      }
    }

    function isValidTowerPosition(x, y) {
      // Check path distance with more accurate tolerance
      for (let i = 0; i < path.length - 1; i++) {
        const p1 = path[i];
        const p2 = path[i + 1];

        // Calculate the distance from the point to the line segment
        const segmentLength = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
        const t = Math.max(0, Math.min(1, ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / (segmentLength ** 2)));
        const projection = {
          x: p1.x + t * (p2.x - p1.x),
          y: p1.y + t * (p2.y - p1.y)
        };
        const distance = Math.sqrt((x - projection.x) ** 2 + (y - projection.y) ** 2);

        if (distance < 35) {  // Reduced from 40 to 35
          return false;
        }
      }

      // Check distance from other towers
      for (let tower of gameState.towers) {
        const dx = tower.x - x;
        const dy = tower.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < 45) {  // Reduced from 50 to 45
          return false;
        }
      }

      // Check canvas limits with smaller margin
      if (x < 20 || x > canvas.width - 20 || y < 20 || y > canvas.height - 20) {
        return false;
      }

      return true;
    }

    function drawPlacementPreview() {
      if (gameState.placingTower) {
        const isValid = isValidTowerPosition(gameState.mouseX, gameState.mouseY);

        ctx.fillStyle = isValid ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.arc(gameState.mouseX, gameState.mouseY, 25, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = isValid ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(gameState.mouseX, gameState.mouseY, config.towerRange, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = isValid ? '#8B4513' : '#8B4513';
        ctx.globalAlpha = 0.7;
        ctx.fillRect(gameState.mouseX - 15, gameState.mouseY - 15, 30, 30);
        ctx.fillStyle = '#A0522D';
        ctx.fillRect(gameState.mouseX - 10, gameState.mouseY - 20, 20, 10);
        ctx.globalAlpha = 1.0;
      }
    }

    function drawPath() {
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 30;
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
      }
      ctx.stroke();

      ctx.fillStyle = '#00ff00';
      ctx.fillRect(0, 235, 20, 30);
      ctx.fillText('IN√çCIO', 5, 280);

      ctx.fillStyle = '#ff0000';
      ctx.fillRect(780, 235, 20, 30);
      ctx.fillText('BASE', 785, 280);
    }

    function spawnEnemy() {
      if (gameState.enemiesSpawned < gameState.enemiesPerWave) {
        const enemy = new Enemy();
        gameState.enemies.push(enemy);
        gameState.enemiesSpawned++;
        gameState.enemiesLeft++;

        setTimeout(() => {
          if (gameState.waveActive && gameState.enemiesSpawned < gameState.enemiesPerWave) {
            spawnEnemy();
          }
        }, config.spawnDelay - (gameState.wave - 1) * 100);
      }
    }

    function updateGame() {
      if (gameState.gameOver) return;

      gameState.enemies.forEach(enemy => enemy.update());
      gameState.towers.forEach(tower => tower.update());
      gameState.bullets.forEach(bullet => bullet.update());

      if (gameState.waveActive && gameState.enemies.length === 0 && gameState.enemiesSpawned >= gameState.enemiesPerWave) {
        gameState.waveActive = false;
        gameState.wave++;
        gameState.enemiesPerWave += 2;
        gameState.enemiesSpawned = 0;

        gameState.enemiesKilled = 0;
        gameState.livesLostThisWave = 0;
        gameState.coinsEarnedThisWave = 0;

        updateUI();
        document.getElementById('waveStatus').textContent = `Wave ${gameState.wave - 1} completed! Get ready for the next one.`;
      }

      if (gameState.health <= 0 && !gameState.gameOver) {
        showGameOver();
      }
    }

    function showGameOver() {
      gameState.gameOver = true;
      gameState.waveActive = false;

      document.getElementById('gameOverStats').textContent = `You survived until the Wave ${gameState.wave}!`;
      document.getElementById('finalStats').innerHTML = `
                <strong>Final Statistics:</strong><br>
                üëæ Enemies eliminated: ${gameState.totalEnemiesKilled}<br>
                üí∞ Total coins earned: ${gameState.totalCoinsEarned}<br>
                üèóÔ∏è Towers built: ${gameState.towers.length}
            `;
      document.getElementById('gameOverModal').classList.remove('hidden');
    }

    function render() {
      if (!gameState.gameStarted) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawPath();
      drawPlacementPreview();

      gameState.towers.forEach(tower => tower.draw());
      gameState.enemies.forEach(enemy => enemy.draw());
      gameState.bullets.forEach(bullet => bullet.draw());

      if (gameState.selectedTower) {
        const tower = gameState.selectedTower;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(10, 10, 200, 80);

        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Tower level ${tower.level}`, 20, 30);
        ctx.fillText(`Damage: ${tower.damage}`, 20, 45);
        ctx.fillText(`Range: ${tower.range}`, 20, 60);

        if (tower.level < 3) {
          ctx.fillText(`Upgrade: üí∞${tower.getUpgradeCost()}`, 20, 75);
        }
        ctx.fillText(`Sell: üí∞${tower.getSellValue()}`, 110, 75);
      }

      if (gameState.waveActive) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(canvas.width - 220, 10, 200, 100);

        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Wave ${gameState.wave} - In progress`, canvas.width - 210, 30);
        ctx.fillText(`üëæ Eliminated: ${gameState.enemiesKilled}/${gameState.enemiesPerWave}`, canvas.width - 210, 50);
        ctx.fillText(`‚ù§Ô∏è Lives lost: ${gameState.livesLostThisWave}`, canvas.width - 210, 70);
        ctx.fillText(`üí∞ Coins earned: ${gameState.coinsEarnedThisWave}`, canvas.width - 210, 90);
      } else if (gameState.wave > 1) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(canvas.width - 220, 10, 200, 120);

        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Total Statistics`, canvas.width - 210, 30);
        ctx.fillText(`Waves completed: ${gameState.wave - 1}`, canvas.width - 210, 50);
        ctx.fillText(`üëæ Total eliminated: ${gameState.totalEnemiesKilled}`, canvas.width - 210, 70);
        ctx.fillText(`‚ù§Ô∏è Total lives lost: ${gameState.totalLivesLost}`, canvas.width - 210, 90);
        ctx.fillText(`üí∞ Total coins earned: ${gameState.totalCoinsEarned}`, canvas.width - 210, 110);
      }

      updateGame();
      requestAnimationFrame(render);
    }

    function updateUI() {
      document.getElementById('coins').textContent = gameState.coins;
      document.getElementById('health').textContent = gameState.health;
      document.getElementById('wave').textContent = gameState.wave;
      document.getElementById('enemiesLeft').textContent = gameState.enemiesLeft;

      const buyBtn = document.getElementById('buyTower');
      if (gameState.placingTower) {
        buyBtn.textContent = 'Cancel Purchase';
        buyBtn.disabled = false;
        buyBtn.className = 'btn btn-danger';
      } else {
        buyBtn.textContent = 'Buy Tower (üí∞50)';
        buyBtn.disabled = gameState.coins < config.towerCost;
        buyBtn.className = 'btn btn-primary';
      }

      const startBtn = document.getElementById('startWave');
      startBtn.disabled = gameState.waveActive;
      startBtn.textContent = gameState.waveActive ? 'Wave in Progress' : 'Start Wave';
    }

    function resetGame() {
      gameState = {
        coins: 100,
        health: 20,
        wave: 1,
        enemiesLeft: 0,
        towers: [],
        enemies: [],
        bullets: [],
        waveActive: false,
        placingTower: false,
        enemiesSpawned: 0,
        enemiesPerWave: 5,
        mouseX: 0,
        mouseY: 0,
        selectedTower: null,
        enemiesKilled: 0,
        totalEnemiesKilled: 0,
        livesLostThisWave: 0,
        totalLivesLost: 0,
        coinsEarnedThisWave: 0,
        totalCoinsEarned: 0,
        gameStarted: true,
        gameOver: false
      };
      updateUI();
      document.getElementById('waveStatus').textContent = 'Click "Start Wave"!';
    }

    function startGame() {
      document.getElementById('startScreen').style.display = 'none';
      document.getElementById('gameScreen').classList.add('active');
      gameState.gameStarted = true;
      updateUI();
      render();
    }

    // Event listeners
    document.getElementById('startGameBtn').addEventListener('click', startGame);

    document.getElementById('buyTower').addEventListener('click', () => {
      if (gameState.placingTower) {
        gameState.placingTower = false;
        gameState.selectedTower = null;
        updateUI();
        document.getElementById('waveStatus').textContent = 'Purchase canceled. Ready for battle!';
      } else if (gameState.coins >= config.towerCost) {
        gameState.placingTower = true;
        gameState.selectedTower = null;
        gameState.towers.forEach(t => t.selected = false);
        updateUI();
        document.getElementById('waveStatus').textContent = 'Click on the field to place the tower! (Green = valid, Red = invalid)';
      }
    });

    document.getElementById('startWave').addEventListener('click', () => {
      if (!gameState.waveActive) {
        gameState.waveActive = true;
        gameState.enemiesSpawned = 0;
        gameState.enemiesLeft = gameState.enemiesPerWave;

        gameState.enemiesKilled = 0;
        gameState.livesLostThisWave = 0;
        gameState.coinsEarnedThisWave = 0;

        document.getElementById('waveStatus').textContent = `Wave ${gameState.wave} Started! Defend your base!`;
        spawnEnemy();
        updateUI();
      }
    });

    document.getElementById('resetGame').addEventListener('click', () => {
      if (confirm('Are you sure you want to restart the game??')) {
        resetGame();
      }
    });

    document.getElementById('restartBtn').addEventListener('click', () => {
      document.getElementById('gameOverModal').classList.add('hidden');
      resetGame();
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      gameState.mouseX = e.clientX - rect.left;
      gameState.mouseY = e.clientY - rect.top;
    });

    canvas.addEventListener('click', (e) => {
      if (gameState.gameOver) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (gameState.placingTower) {
        if (isValidTowerPosition(x, y)) {
          gameState.coins -= config.towerCost;
          gameState.towers.push(new Tower(x, y));
          gameState.placingTower = false;
          gameState.selectedTower = null;
          updateUI();
          document.getElementById('waveStatus').textContent = 'Tower built! Prepare for battle.';
        } else {
          document.getElementById('waveStatus').textContent = 'Invalid position! Please choose another location..';
        }
      } else {
        let towerClicked = false;

        for (let tower of gameState.towers) {
          if (tower.selected) {
            if (tower.isPointInUpgradeButton(x, y) && tower.level < 3) {
              const upgradeCost = tower.getUpgradeCost();
              if (gameState.coins >= upgradeCost) {
                gameState.coins -= upgradeCost;
                tower.upgrade();
                updateUI();
                document.getElementById('waveStatus').textContent = `Improved tower to level ${tower.level}!`;
              } else {
                document.getElementById('waveStatus').textContent = 'Insufficient coins for upgrade!';
              }
              towerClicked = true;
              break;
            } else if (tower.isPointInSellButton(x, y)) {
              const sellValue = tower.getSellValue();
              gameState.coins += sellValue;
              const index = gameState.towers.indexOf(tower);
              gameState.towers.splice(index, 1);
              gameState.selectedTower = null;
              updateUI();
              document.getElementById('waveStatus').textContent = `Tower sold for üí∞${sellValue}!`;
              towerClicked = true;
              break;
            }
          }

          if (tower.isPointInside(x, y)) {
            gameState.towers.forEach(t => t.selected = false);
            tower.selected = true;
            gameState.selectedTower = tower;
            towerClicked = true;
            break;
          }
        }

        if (!towerClicked) {
          gameState.towers.forEach(t => t.selected = false);
          gameState.selectedTower = null;
        }
      }
    });

    // Start
    updateUI();
  </script>

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6670620026273302"
    crossorigin="anonymous"></script>
</body>

</html>